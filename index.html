<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="woj1208 Sherlock&#39;s Code : woj1208解题报告">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>woj1208 Sherlock&#39;s Code</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/bat001/woj">View on GitHub</a>

          <h1 id="project_title">woj1208 Sherlock&#39;s Code</h1>
          <h2 id="project_tagline">woj1208解题报告</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/bat001/woj/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/bat001/woj/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="题目链接" class="anchor" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>题目链接</h1>

<p><br><a href="http://acm.whu.edu.cn/learn/problem/detail?problem_id=1208">woj1208 Sherlock's Code</a>
<br>题目的大概意思就是输入两个长度为N的数组，计算数组的两两之和，得到N^2个数后，从小到大排序，输出前N个数。</p>

<h1>
<a id="数据规模" class="anchor" href="#%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据规模</h1>

<p>数组的长度1 &lt;= N &lt;= 50000；空间限制：65536KB；时间限制是1s.</p>

<h1>
<a id="解题思路" class="anchor" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>解题思路</h1>

<p><br>拿到题的第一想法就是，肯定不能直接按照题目的意思去做，因为这样做内存很容易超。需要另辟思路，第一个想法是用一个规模为N的堆(大根堆)去维护输出的结果。遍历计算，每次得到一个和值，就与堆顶的元素相比较，如果该和值比堆顶元素小，就将堆顶元素出堆，将该元素入堆，重新调整堆。当所有元素遍历完以后，再对这个大根堆进行一次排序，然后输出即可。代码如下：</p>

<pre><code>
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    freopen("in.txt","r",stdin);
    int n;
    while(cin&gt;&gt;n)
    {
        vector&lt;int&gt; va,vb,vheap;
        int temp;
        for(int i=0;i&lt;n;++i)
        {
            cin&gt;&gt;temp;
            va.push_back(temp);
        }
        for(int i=0;i&lt;n;++i)
        {
            cin&gt;&gt;temp;
            vb.push_back(temp);
        }

        for(int i=0;i&lt;n;++i)//初始化堆 
        {
            temp=va[0]+vb[i];
            vheap.push_back(temp);
        }
        make_heap(vheap.begin(),vheap.end()); 

        for(int i=1;i&lt;n;++i)
        {
            for(int j=0;j&lt;n;++j)
            {
                int temp=va[i]+vb[j];
                if(temp&lt;vheap[0])//小于堆顶元素则重新调整堆
                {
                    vheap.erase(vheap.begin());//删除堆顶元素
                    vheap.push_back(temp);//temp入堆
                    make_heap(vheap.begin(),vheap.end());
                }
            }
        }
        sort_heap(vheap.begin(),vheap.end());
        cout&lt;&lt;vheap[0];
        for(int i=1;i&lt;n;++i)
            cout&lt;&lt;" "&lt;&lt;vheap[i];
        cout&lt;&lt;endl;
        va.clear();
        vb.clear();
        vheap.clear();
    }
    return 0;
}
</code></pre>

<p><br>上面的算法复杂度还是比较高的，O(n^2log n)，提交超时也正常。还是沿着这种思路，稍微优化修改一下就行了。上面的代码比较粗糙。
<br>这题的优化解法可以参考《算法导论》中k路归并算法，可以这样考虑，将a[n]和b[n]排序后，用b[n]中的每个元素去加a[n]中的一个元素，得到n个有序表，再把这n个有序表合并成一个有序表即可。
<br>得到的n个有序表如下：
<br>a[0]+b[0]&lt;= a[0]+b[1]&lt;= a[0]+b[2]&lt;=…&lt;= a[0]+b[n-1];
<br>a[1]+b[0]&lt;= a[1]+b[1]&lt;= a[1]+b[2]&lt;=…&lt;= a[1]+b[n-1];
<br>…
<br>a[n-1]+b[0]&lt;= a[n-1]+b[1]&lt;= a[n-1]+b[2]&lt;=…&lt;= a[n-1]+b[n-1].
<br>归并时，可以这样考虑，每个表的元素按序移入一个新表中，把每个表的当前元素放入一个二叉堆中，每次删除最小值并放入新表中，然后加入此序列的下一个元素，直到n个表遍历完。这种算法每次耗时log(n)，n次共耗时nlog(n)，所以AC掉这题是没有问题的。
<br>具体的实现就是：读入a[n]和b[n]，并将其升序排序，再将第一个有序表a[0] + b<a href="0%3C=i%3C=n-1">i</a>读入q向量中，维护一个大小为n的二叉堆。然后考虑第1个有序表，b[1] + a<a href="0%3C=i%3C=n-1">i</a>，如果b[1] + a[i]比堆q的堆顶元素大，则退出，否则删除堆的堆顶元素，插入data2[1] + data1[i]，依次计算其他有序表即可。再q的数据拷贝到a中，并对a按升序排序，输出a中的数据即可。
<br>最终的AC代码如下：</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
using namespace std;  
const int N=50000;
int main()  
{
    freopen("in.txt","r",stdin);
    int n;
    int num1[N];
    int num2[N];
    priority_queue&lt;int,deque&lt;int&gt;,less&lt;int&gt; &gt; big;
    while(scanf("%d",&amp;n)!=EOF)
    { 
        for(int i=0;i&lt;n;i++)  
            scanf("%d",&amp;num1[i]);  
        sort(num1,num1+n);
        for(int j=0;j&lt;n;j++)  
        {  
            scanf("%d",&amp;num2[j]);  
            big.push(num1[0]+num2[j]);  
        }  
        sort(num2,num2+n);  
        for(int k=1;k&lt;n;k++) 
            for(int l=0;l&lt;n;l++)  
            {  
                if(num1[k]+num2[l]&gt;big.top())  
                    break;  
                    big.pop();  
                    big.push(num1[k]+num2[l]);  
            } 
        for(int k=0;k&lt;n;k++)  
        {  
            num1[n-k-1]=big.top();  
            big.pop();  
        }
        printf("%d",num1[0]);  
        for(int i=1;i&lt;n;i++)  
            printf(" %d",num1[i]);
        //printf("\n");
    }
    return 0;
}
</code></pre>

<p><br>更多请参考<a href="http://blog.csdn.net/u011000290">我的CSDN博客</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">woj1208 Sherlock&#39;s Code maintained by <a href="https://github.com/bat001">bat001</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("bat001");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
